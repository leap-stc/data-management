name: Create a report on bucket sizes in gcs

on:
  workflow_dispatch:
    inputs:
      bucket_prefix:
        description: "optional single bucket to check. ex: leap-persistent/data-library"
        required: false
env:
  RCLONE_CONFIG_GCS_TYPE: google cloud storage

jobs:
  size-report:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v5

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.LEAP_BAKERY_SERVICE_ACCOUNT }}"

      - name: Setup Rclone
        uses: AnimMouse/setup-rclone@v1
        with:
          rclone_config: |
            [gcs]
            type = google cloud storage
          disable_base64: true

      - name: Generate bucket size report
        id: report
        run: |
          #!/bin/bash
          set -x
          set -euo pipefail

          input_prefix="${{ github.event.inputs.bucket_prefix || '' }}"

          if [[ -n "$input_prefix" ]]; then
            bucket_prefixes=("$input_prefix")
            echo "$bucket_prefixes"
          else
            bucket_prefixes=(
              leap-persistent
              leap-persistent-ro
              leap-persistent/data-library
            )
          fi

          echo "${bucket_prefixes[@]}"
          REPORT_HEADER="*Bucket Size Report*"
          REPORT_TABLE=$(cat <<EOF
| Bucket/Prefix | Size |
|---|---|
EOF
          )

          for prefix in "${bucket_prefixes[@]}"; do
            echo "gcs:$prefix"
            
            # The lsd command might not find any dirs, leading to an empty dirs variable.
            # Adding || true handles this gracefully.
            dirs=$(rclone lsd "gcs:$prefix" --max-depth 1 | awk '{print $NF}' || true)
            
            for dir in $dirs; do

              if [[ -z "$dir" || "$dir" == "." ]]; then
                continue
              fi


              size_json=$(rclone size "gcs:$prefix/$dir" --fast-list --json)
              bytes=$(echo "$size_json" | jq '.bytes')
              human_size=$(numfmt --to=iec --suffix=B "$bytes")

              REPORT_TABLE+="\n| $prefix/$dir | $human_size |"
            done
          done
          
          # The table needs to be a single, properly escaped JSON string for the payload.
          # Concatenate the header and table with newlines.
          # Using printf with %q for shell-safe string creation to pass to jq.
          REPORT_MESSAGE="${REPORT_HEADER}\n\`\`\`\n${REPORT_TABLE}\n\`\`\`"
          
          # Using `jq -rRs` will handle the multi-line string as a raw string
          # with escaping, but since we are using `<<EOF`, we can pass it
          # directly to `jq -R` to avoid double escaping.
          json_safe_report=$(echo "$REPORT_MESSAGE" | jq -R)
          
          echo "report=$json_safe_report" >> $GITHUB_OUTPUT

      - name: Post bucket report to Slack
        uses: slackapi/slack-github-action@v2.1.1
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ${{ steps.report.outputs.report }}
                  }
                }
              ]
            }
